# مـؤجلات (Promises)
[[English]](readme.md)

مكتبة بسيطة لدعم المؤجلات (promises) في لغة الأسس.

توفر هذه المكتبة الدعم لمختلف وظائف المؤجلات بشكل مستقل عن المكان الذي سيتم استعمالها فيه. لا تقوم هذه المكتبة بتوفير حلقة أحداث (event loop)، حيث يجب على المكان الذي سيتم استعمالها فيه توفير ذلك بشكل متوافق مع هذه المكتبة.

## الإضافة إلى المشروع

يمكن تثبيت هذه المكتبة باستعمال التعليمات البرمجية التالية:

<div dir=rtl>

```
اشمل "مـحا"؛
مـحا.اشمل_ملف("Alusus/Promises"، "مـؤجلات.أسس")؛
```

</div>

```
import "Apm";
Apm.importFile("Alusus/Promises");
```

## مثال

<div dir=rtl>

```
اشمل "مـتم/طـرفية"؛
اشمل "مـتم/نـص"؛
اشمل "مـتم/مـصفوفة"؛
اشمل "مـتم/سندات"؛
اشمل "مـحا"؛
مـحا.اشمل_ملف("Alusus/Promises"، "مـؤجلات.أسس")؛

استخدم مـتم؛
استخدم مـؤجلات؛

// نقوم بتعريف صف يمثل رقم، لاستعماله في الأمثلة التالية
صنف رقـم {
    عرف القيمة: صـحيح؛
    عملية هذا~هيئ() هذا.القيمة = 0؛
    عملية هذا~هيئ(i: صـحيح) هذا.القيمة = i؛
    عملية هذا~هيئ(i: سند[رقـم]) هذا.القيمة = i.القيمة؛
    عملية هذا = سند[رقـم] هذا.القيمة = value.القيمة؛
}

// اختبر مـؤجلة.
دالة اختبر_مؤجلة {
    طـرفية.اطبع("اختبر مـؤجلة:\ج")؛
    // نقوم بإنشاء مؤجلة نمط القيمة المرجعة لها هو Num
    عرف مؤجلة: سـندنا[مـؤجلة[رقـم]] = مـؤجلة[رقـم].أنشئ()؛
    طـرفية.اطبع("مؤجلة 1 - الحالة: %d، النتيجة: %d\ج"، مؤجلة.الحالة، مؤجلة.النتيجة.القيمة)؛

    // نقوم بإقرار المؤجلة بحيث تكون النتيجة هي كائن من الصف Num يحمل القيمة 5
    مؤجلة.قرر(رقـم(5))؛
    طـرفية.اطبع("مؤجلة 1 - الحالة: %d، النتيجة: %d\ج"، مؤجلة.الحالة، مؤجلة.النتيجة.القيمة)؛

    // نقوم برفض المؤجلة مع خطأ له الرمز 1 و رسالة مناسبة
    مؤجلة.ارفض(مثل_سندنا[سـندنا[خـطأ_عام]().{
        أنشئ()؛
        الرمز = 1؛
        الرسالة = نـص("خطأ غير معروف 1")؛
    }، خـطأ])؛
    طـرفية.اطبع("مؤجلة 1 - الحالة: %d، الخطأ: %ld\ج"، مؤجلة.الحالة، مؤجلة.الخطأ.obj~ptr)؛
}
اختبر_مؤجلة()؛

// اختبر مـؤجلة.ثم
دالة اختبر_مؤجلة_ثم {
    طـرفية.اطبع("\جاختبر مـؤجلة.ثم:\ج")؛
    // Num نقوم بإنشاء مؤجلة نمط القيمة المرجعة لها هو
    عرف مؤجلة: سـندنا[مـؤجلة[رقـم]] = مـؤجلة[رقـم].أنشئ()؛

    // نقوم بتحديد ما يجب تنفيذه بعد تنفيذ المؤجلة
    // هنا ما سيتم تنفيذه هو طباعة رسالة و إقرار المؤجلة
    عرف ثم: سـندنا[مـؤجلة[نـص]] = مؤجلة.ثم[نـص](
        مغلفة (مدخل: رقـم، م: سند[مـؤجلة[نـص]]) {
            طـرفية.اطبع("أطلقت مـؤجلة.ثم\ج")؛
            م.قرر(نـص("مـؤجلة.ثم - النتيجة المستلمة: ") + مدخل.القيمة)؛
        }
    )؛
    طـرفية.اطبع("الحالة: %d، النتيجة: %s\ج"، ثم.الحالة، ثم.النتيجة.صوان)؛
    مؤجلة.قرر(رقـم(6))؛
    طـرفية.اطبع("الحالة: %d، النتيجة: %s\ج"، ثم.الحالة، ثم.النتيجة.صوان)؛
}
اختبر_مؤجلة_ثم()؛
```

</div>

```
import "Srl/Console";
import "Apm";
Apm.importFile("Alusus/Promises");

use Srl;
use Promises;

// نقوم بتعريف صف يمثل رقم، لاستعماله في الأمثلة التالية
class Num {
    def val: Int;
    handler this~init() this.val = 0;
    handler this~init(i: Int) this.val = i;
    handler this~init(i: ref[Num]) this.val = i.val;
    handler this = ref[Num] this.val = value.val;
}


func testPromise {
    Console.print("Test Promise:\n");
    // Num نقوم بإنشاء مؤجلة نمط القيمة المرجعة لها هو
    def promise: SrdRef[Promise[Num]] = Promise[Num].new();
    Console.print("promise 1 - status: %d, value: %d\n", promise.status, promise.result.val);

    //يحمل القيمة 5 Num  نقوم بإقرار المؤجلة بحيث تكون النتيجة هي كائن من الصف
    promise.resolve(Num(5));
    Console.print("promise 1 - status: %d, value: %d\n", promise.status, promise.result.val);

    // نقوم برفض المؤجلة مع خطأ له الرمز 1 و رسالة مناسبة
    promise.reject(castSrdRef[SrdRef[GenericError]().{
        construct();
        code = 1;
        message = String("Unknown error 1");
    }, Error]);
    Console.print("promise 1 - status: %d, error: %ld\n", promise.status, promise.error.obj~ptr);
}
testPromise();


func testPromiseThen {
    Console.print("\nTest Promise.then:\n");
    // Num نقوم بإنشاء مؤجلة نمط القيمة المرجعة لها هو
    def promise: SrdRef[Promise[Num]] = Promise[Num].new();

    // نقوم بتحديد ما يجب تنفيذه بعد تنفيذ المؤجلة
    // هنا ما سيتم تنفيذه هو طباعة رسالة و إقرار المؤجلة
    def then: SrdRef[Promise[String]] = promise.then[String](
        closure (input: Num, p: ref[Promise[String]]) {
            Console.print("ThenPromise triggered\n");
            p.resolve(String("ThenPromise - received value: ") + input.val);
        }
    );
    Console.print("status: %d, value: %s\n", then.status, then.result.buf);
    promise.resolve(Num(6));
    Console.print("status: %d, value: %s\n", then.status, then.result.buf);
}
testPromiseThen();
```

## الأصناف و التوابع

### الصنف مـؤجلة (Promise)

<div dir=rtl>

```
صنف مـؤجلة [نـوع_الـنتيجة: نوع]{
    عرف الحالة: صـحيح = حـالة._جديد_؛
    عرف النتيجة: نـوع_الـنتيجة؛
    عرف الخطأ: سـندنا[خـطأ]؛
}
```

</div>

```
class Promise [ResultType: type] {
    def status: Int = Status.NEW;
    def result: ResultType;
    def error: SrdRef[Error];
}
```
هذا الصنف عبارة عن قالب لتخزين معلومات المؤجلة لمختلف أنواع النتائج.

`الحالة` (`status`) يعبر عن الحالة الحالية للمؤجلة.

`النتيجة` (`result`) النتيجة المرجعة من المؤجلة.

`الخطأ` (`error`) الخطأ الذي حصل أثناء محاولة تنفيذ المؤجلة.

### قرر (resolve)

<div dir=rtl>

```
عرف قرر: (نتيجة: نـوع_الـنتيجة)؛
```

</div>

```
handler this.resolve(res: ResultType);
```

وظيفة يمكن عن طريقها اقرار المؤجلة بتحويل حالتها من `__جديد__` إلى `__مقرر__` و تخزين النتيجة.

المعطيات:

`نتيجة` (`res`) النتيجة التي يجب تخزينها في المؤجلة على أنها نتيجة التنفيذ.

### ارفض (reject)

<div dir=rtl>

```
عرف ارفض: (خطأ: سندنا[خـطأ])؛
```

</div>

```
handler this.reject(err: SrdRef[Error]);
```

وظيفة يمكن عن طريقها رفض المؤجلة بتحويل حالتها من `__جديد__` إلى `__مرفوض__` و تخزين الخطأ الذي حصل.

المعطيات:

`خطأ` (`error`) الخطأ الذي يجب تخزينه في المؤجلة على أنه الخطأ الحاصل أثناء التنفيذ.

### أنشئ (new)

<div dir=rtl>

```
عرف ارفض: (): سندنا[مـؤجلة[نـوع_الـنمط]]؛
```

</div>

```
function new (): SrdRef[Promise[ResultType]];
```

قالب وظيفة يمكن عن طريقه إنشاء مؤجلة بنمط قيمة مرجعة محدد.

القيمة المرجعة:

سند إلى مؤجلة من النوع المطلوب.

### ثم (then)

<div dir=rtl>

```
عرف [نـوع_ثـم: نوع] ثم(
    منادى: دالةـمغلفة(دخل: نـوع_الـنتيجة، مـؤجلة: سند[مـؤجلة[نـوع_ثـم]])
): سندنا[مـؤجلة[نـوع_ثـم]]؛
```

</div>

```
handler [ThenType: type] this.then(
    callback: closure (input: ResultType, promise: ref[Promise[ThenType]])
): SrdRef[Promise[ThenType]];
```

قالب وظيفة يمكن من خلاله تحديد ما يجب تنفيذه بعد أن يتم الإنتهاء من تنفيذ مؤجلة.

المعطيات:

`منادى` (`callback`) عبارة عن دالة مغلفة تحدد ما الذي يجب تنفيذه كنتيجة للمؤجلة.

القيمة المرجعة:

سند لمؤجلة نمط النتيجة الخاصة بها يحدده القالب.

### اقبض (catch)

<div dir=rtl>

```
عرف اقبض(
    منادى: دالةـمغلفة(خطأ: سندنا[خـطأ]، مـؤجلة: سند[مـؤجلة[نـوع_الـنتيجة]])
): سندنا[مـؤجلة[نـوع_الـنتيجة]]؛
```

</div>

```
handler this.catch(
    callback: closure (err: SrdRef[Error], promise: ref[Promise[ResultType]])
): SrdRef[Promise[ResultType]];
```

وظيفة يمكن من خلالها تحديد ما يجب تنفيذه عند حدوث خطأ أثناء تنفيذ مؤجلة.

المعطيات:

`منادى` (`callback`) عبارة عن دالة مغلفة تحدد ما الذي يجب تنفيذه عند حدوث الخطأ.

القيمة المرجعة:

سند لمؤجلة نمط النتيجة الخاصة بها يحدده القالب.

### الكل (all)

<div dir=rtl>

```
عرف الكل (
    الدخل: مـصفوفة[سندنا[مـؤجلة[نـوع_الـنتيجة]]]
): سندنا[مـؤجلة[نـوع_الـنتيجة]]؛
```

</div>

```
function all (inputs: Array[SrdRef[Promise[ResultType]]]): SrdRef[Promise[Array[ResultType]]];
```

دالة يمكن من خلالها تحديد مجموعة من المؤجلات، بحيث تكون المؤجلة المرجعة محققة في حال تحققت كافة المؤجلات،
و غير محققة في حال كانت واحدة على الأقل من المؤجلات غير محققة..

المعطيات:

`الدخل` (`inputs`) مجموعة المؤجلات التي تعتمد عليها المؤجلة التي يتم إرجاعها.

القيمة المرجعة:

سند لمؤجلة نمط النتيجة الخاصة بها يحدده القالب.

### تجاهل_النتيجة (ignoreResult)

<div dir=rtl>

```
عرف تجاهل_النتيجة: (): سندنا[مـؤجلة[صـحيح]]؛
```

</div>

```
handler this.ignoreResult(): SrdRef[Promise[Int]];
```

وظيفة يمكن من خلالها إهمال نتيجة مؤجلة.

يمكن استعمال هذه الوظيفة لإهمال النتيجة في حال استعمال دالة `الكل` لمجموعة من المؤجلات بأصناف مختلفة.
حيث أن دالة `الكل` تحتاج مجموعة من المؤجلات لها نفس الصنف و إلا يعطي المترجم خطأ.

القيمة المرجعة:

سند إلى مؤجلة لها قيمة معادة Int، و تكون قيمة النتيجة هي 0 للدلالة على أنها مهملة.

### حـالة (Status)

<div dir=rtl>

```
صنف حـالة {
    عرف _جديد_: 0؛
    عرف _مقرر_: 1؛
    عرف _مرفوض_: 2؛
}
```

</div>

```
def Status: {
    def NEW: 0;
    def RESOLVED: 1;
    def REJECTED: 2;
}
```

يستعمل هذا الصنف لتحديد حالة المؤجلة.

### خـطأ (Error)

<div dir=rtl>

```
صنف خـطأ {
    عرف هات_الرمز(): صـحيح كمؤشر؛
    عرف هات_الرسالة(): نـص كمؤشر؛
}
```

</div>

```
class Error {
    handler this.getCode(): Int as_ptr;
    handler this.getMessage(): String as_ptr;
}
```

يحمل هذا الصنف معلومات الخطأ عن طريق وظيفتين:

`هات_الرمز` (`getCode`) تستعمل هذه الوظيفة لجلب رمز الخطأ.

`هات_الرسالة` (`getMessage`) تستعمل هذه الوظيفة لجلب رسالة الخطأ.

هذا الصنف هو صنف مجرد، و بالتالي يجب على صف ابن أن يقوم بتحقيق هذه الوظائف.

### خـطأ_عـام (GenericError)

<div dir=rtl>

```
صنف خـطأ_عام {
    @حقنة عرف خطأ: خـطأ؛
    عرف الرمز: صـحيح؛
    عرف الرسالة: نـص؛
    عملية (هذا: خـطأ).هات_الكود(): صـحيح كمؤشر؛
    عملية (هذا: خـطأ).هات_الرسالة(): نـص كمؤشر؛
}
```

</div>

```
class GenericError {
    @injection def error: Error;
    def code: Int;
    def message: String;
    handler (this: Error).getCode(): Int set_ptr;
    handler (this: Error).getMessage(): String set_ptr;
}
```
هذا الصنف هو تحقيق للصنف المجرد `خـطأ`.

و هو يقوم بتخزين رمز و رسالة الخطأ و يحقق الوظيفتين اللتين تعيدان رمز و رسالة الخطأ.

